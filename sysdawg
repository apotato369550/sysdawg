#!/usr/bin/env bash

# sysdawg - Junior SRE Copilot powered by Mistral 7B
# A read-only diagnostic assistant for system administration
# Runs on orion, queries Mistral 7B on apollo via SSH

set -euo pipefail

# Configuration
# Resolve through symlinks to get actual script location
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
ENV_FILE="${SCRIPT_DIR}/.env"
SYSDAWG_CONTEXT_FILE="${SCRIPT_DIR}/SYSDAWG.md"
OLLAMA_MODEL="mistral"
OLLAMA_API_URL="http://localhost:11434/api/chat"

# Default values (used if .env doesn't exist)
DEFAULT_APOLLO_HOST="apollo.local"
DEFAULT_APOLLO_USER="$USER"
DEFAULT_APOLLO_PORT="22"

# Global state
SYSDAWG_CONTEXT=""
CURRENT_DIAGNOSTICS=""
DIAGNOSTICS_TIMESTAMP=""
INCLUDE_DIAGNOSTICS=true
CONVERSATION_HISTORY=()
MAX_HISTORY_TURNS=10
DEBUG_MODE=false

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# ============================================================================
# Helper Functions
# ============================================================================

log_error() {
  echo -e "${RED}✗ Error: $*${NC}" >&2
}

log_warn() {
  echo -e "${YELLOW}⚠ $*${NC}" >&2
}

log_info() {
  echo -e "${BLUE}ℹ $*${NC}" >&2
}

log_success() {
  echo -e "${GREEN}✓ $*${NC}" >&2
}

show_help() {
  cat <<EOF
${CYAN}sysdawg${NC} - Junior SRE Copilot

${BLUE}Usage:${NC}
  sysdawg                    # Start interactive chat (default)
  sysdawg -p "question"      # One-shot question (headless)
  sysdawg -i, --interactive  # Explicitly start interactive mode
  sysdawg --setup            # Configure SSH
  sysdawg -h, --help         # Show this help

${BLUE}Examples:${NC}
  sysdawg                    # Opens interactive chat
  sysdawg -p "why is my disk slow?"
  sysdawg --setup            # First time setup

${BLUE}About:${NC}
  sysdawg is a read-only diagnostic tool that leverages Mistral 7B running
  on apollo to help diagnose system issues. It gathers diagnostics and sends
  them to Mistral for conversational analysis and advice.

  Never runs commands. Always advisory. Friendly junior SRE vibes.

EOF
}

# Check .env file exists (now optional)
check_env() {
  if [ ! -f "$ENV_FILE" ]; then
    log_info ".env file not found, using defaults"
    return 0
  fi
  return 0
}

# Load and validate environment
load_env() {
  # Load .env if it exists, otherwise use defaults
  if [ -f "$ENV_FILE" ]; then
    # shellcheck disable=SC1090
    source "$ENV_FILE" 2>/dev/null || {
      log_warn "Failed to load .env file, using defaults"
    }
  fi

  # Use defaults if not set
  APOLLO_HOST="${APOLLO_HOST:-$DEFAULT_APOLLO_HOST}"
  APOLLO_USER="${APOLLO_USER:-$DEFAULT_APOLLO_USER}"
  APOLLO_PORT="${APOLLO_PORT:-$DEFAULT_APOLLO_PORT}"

  # Show what we're using
  if [ ! -f "$ENV_FILE" ]; then
    log_info "Using default connection: $APOLLO_USER@$APOLLO_HOST:$APOLLO_PORT"
    echo ""
    echo "  To customize, create: $ENV_FILE"
    echo ""
  fi
}

# Load sysdawg context/persona
load_sysdawg_context() {
  if [ ! -f "$SYSDAWG_CONTEXT_FILE" ]; then
    log_error "SYSDAWG.md not found at $SYSDAWG_CONTEXT_FILE"
    exit 1
  fi

  SYSDAWG_CONTEXT=$(<"$SYSDAWG_CONTEXT_FILE")
}

# Test SSH connection
test_ssh_connection() {
  log_info "Testing SSH connection to $APOLLO_USER@$APOLLO_HOST:$APOLLO_PORT"

  if ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" "echo 'SSH OK'" >/dev/null 2>&1; then
    log_success "SSH connection successful"
    return 0
  else
    log_error "SSH connection failed"
    echo ""
    echo "Troubleshooting:"
    echo "  1. Check apollo is reachable: ping $APOLLO_HOST"
    echo "  2. Check .env credentials"
    echo "  3. Run: sysdawg --setup"
    echo ""
    exit 1
  fi
}

# Gather system diagnostics
gather_diagnostics() {
  local diagnostics=""

  diagnostics+="=== SYSTEM INFO ==="$'\n'
  diagnostics+="$(uname -a)"$'\n'
  diagnostics+=$'\n'

  diagnostics+="=== UPTIME ==="$'\n'
  diagnostics+="$(uptime)"$'\n'
  diagnostics+=$'\n'

  diagnostics+="=== MEMORY ==="$'\n'
  diagnostics+="$(free -h)"$'\n'
  diagnostics+=$'\n'

  diagnostics+="=== DISK SPACE ==="$'\n'
  diagnostics+="$(df -h)"$'\n'
  diagnostics+=$'\n'

  diagnostics+="=== LOAD AVERAGE ==="$'\n'
  diagnostics+="$(cat /proc/loadavg)"$'\n'
  diagnostics+=$'\n'

  # Get last 50 lines of systemd journal
  diagnostics+="=== RECENT SYSTEMD LOG ==="$'\n'
  diagnostics+="$(journalctl -b --no-pager | tail -n 50)"$'\n'

  echo "$diagnostics"
}

# Refresh diagnostics
refresh_diagnostics() {
  log_info "Refreshing system diagnostics..."
  CURRENT_DIAGNOSTICS=$(gather_diagnostics)
  DIAGNOSTICS_TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
  log_success "Diagnostics refreshed at $DIAGNOSTICS_TIMESTAMP"
}

# Trim conversation history to max turns
trim_history() {
  local history_size=${#CONVERSATION_HISTORY[@]}
  local max_entries=$((MAX_HISTORY_TURNS * 2))

  if [ $history_size -gt $max_entries ]; then
    # Remove oldest 2 entries (user message + response)
    CONVERSATION_HISTORY=("${CONVERSATION_HISTORY[@]:2}")
  fi
}

# Build conversation history string
build_history_string() {
  local history_str=""
  local i
  for ((i = 0; i < ${#CONVERSATION_HISTORY[@]}; i += 2)); do
    if [ $i -lt ${#CONVERSATION_HISTORY[@]} ] && [ $((i + 1)) -lt ${#CONVERSATION_HISTORY[@]} ]; then
      history_str+="User: ${CONVERSATION_HISTORY[$i]}"$'\n\n'
      history_str+="Assistant: ${CONVERSATION_HISTORY[$((i + 1))]}"$'\n\n'
    fi
  done
  echo "$history_str"
}

# Build system message (personality and rules)
build_system_message() {
  echo "$SYSDAWG_CONTEXT"
}

# Build user message with context
build_user_message() {
  local user_question="$1"
  local message=""

  # Add diagnostics if enabled
  if [ "$INCLUDE_DIAGNOSTICS" = true ]; then
    message+="[SYSTEM DIAGNOSTICS - gathered at $DIAGNOSTICS_TIMESTAMP]"$'\n'
    message+="$CURRENT_DIAGNOSTICS"$'\n'
    message+="[END DIAGNOSTICS]"$'\n\n'
  fi

  # Add conversation history if exists
  if [ ${#CONVERSATION_HISTORY[@]} -gt 0 ]; then
    message+="[CONVERSATION HISTORY]"$'\n'
    message+="$(build_history_string)"
    message+="[END HISTORY]"$'\n\n'
  fi

  # Add the actual user question with emphasis
  message+="**USER QUESTION:** $user_question"

  echo "$message"
}

# Escape JSON string (bash-native, no jq needed)
json_escape() {
  local string="$1"
  # Order matters: escape backslashes first!
  string="${string//\\/\\\\}"
  string="${string//\"/\\\"}"
  # Replace actual newlines with \n escape sequence
  string="${string//$'\n'/\\n}"
  string="${string//$'\t'/\\t}"
  string="${string//$'\r'/\\r}"
  # Remove any control characters that might break JSON
  string="${string//$'\f'/}"
  string="${string//$'\b'/}"
  echo -n "$string"
}

# Send prompt to Mistral via apollo using Ollama API (jq-free)
send_to_mistral() {
  local system_message="$1"
  local user_message="$2"

  # Escape messages for JSON
  local escaped_system escaped_user
  escaped_system=$(json_escape "$system_message")
  escaped_user=$(json_escape "$user_message")

  # Build JSON request manually (bash-native)
  local json_request
  read -r -d '' json_request <<EOF || true
{
  "model": "$OLLAMA_MODEL",
  "messages": [
    {"role": "system", "content": "$escaped_system"},
    {"role": "user", "content": "$escaped_user"}
  ],
  "stream": false,
  "options": {
    "temperature": 0.7,
    "top_p": 0.9
  }
}
EOF

  # Debug output if enabled
  if [ "$DEBUG_MODE" = true ]; then
    echo "=== DEBUG: JSON Request ===" >&2
    echo "$json_request" | head -c 500 >&2
    echo -e "\n... (truncated)\n===========================" >&2
  fi

  # Send request to apollo via SSH (pipe JSON through stdin to avoid escaping issues)
  local response
  response=$(printf "%s" "$json_request" | ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" \
    "cat | curl -s -X POST '$OLLAMA_API_URL' -H 'Content-Type: application/json' -d @-" 2>&1) || {
    log_error "Failed to communicate with Mistral on apollo"
    return 1
  }

  # Debug output if enabled
  if [ "$DEBUG_MODE" = true ]; then
    echo "=== DEBUG: API Response ===" >&2
    echo "$response" | head -c 500 >&2
    echo -e "\n... (truncated)\n===========================" >&2
  fi

  # Extract message content from response (bash-native parsing)
  local message_content
  if echo "$response" | grep -q '"message"'; then
    # Extract content field - handle escaped quotes and newlines
    # Find the "content" field and extract everything until the closing quote
    message_content=$(echo "$response" | sed -n 's/.*"content":"\(.*\)","role".*/\1/p')

    # If that didn't work, try a simpler approach
    if [ -z "$message_content" ]; then
      message_content=$(echo "$response" | sed -n 's/.*"content":"\([^}]*\)".*/\1/p')
    fi

    # Unescape JSON escapes
    message_content=$(echo "$message_content" | sed 's/\\n/\n/g' | sed 's/\\"/"/g' | sed 's/\\\\/\\/g')
  fi

  if [ -z "$message_content" ]; then
    log_error "Failed to parse response from Mistral"
    echo "Raw response: $response" >&2
    return 1
  fi

  echo "$message_content"
}

# Run comprehensive tests
run_tests() {
  local failed_tests=0
  local passed_tests=0

  echo ""
  echo -e "${CYAN}╔════════════════════════════════════════════════════╗${NC}"
  echo -e "${CYAN}║${NC}          ${CYAN}Running sysdawg Test Suite${NC}                ${CYAN}║${NC}"
  echo -e "${CYAN}╚════════════════════════════════════════════════════╝${NC}"
  echo ""

  # Test 1: Check basic tools
  echo -n "Testing basic tools (grep, sed, curl)... "
  if command -v grep &>/dev/null && command -v sed &>/dev/null && command -v curl &>/dev/null; then
    echo -e "${GREEN}✓ PASS${NC}"
    ((passed_tests++))
  else
    echo -e "${RED}✗ FAIL${NC} (missing grep, sed, or curl)"
    ((failed_tests++))
  fi

  # Test 2: Check .env file
  echo -n "Testing .env configuration... "
  if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE" 2>/dev/null
    if [ -n "$APOLLO_HOST" ] && [ -n "$APOLLO_USER" ]; then
      echo -e "${GREEN}✓ PASS${NC}"
      ((passed_tests++))
    else
      echo -e "${RED}✗ FAIL${NC} (missing APOLLO_HOST or APOLLO_USER)"
      ((failed_tests++))
    fi
  else
    echo -e "${RED}✗ FAIL${NC} (.env file not found)"
    ((failed_tests++))
  fi

  # Test 3: SSH connection to apollo
  echo -n "Testing SSH connection to apollo... "
  if ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" "echo 'OK'" &>/dev/null; then
    echo -e "${GREEN}✓ PASS${NC}"
    ((passed_tests++))
  else
    echo -e "${RED}✗ FAIL${NC} (cannot connect to apollo)"
    ((failed_tests++))
  fi

  # Test 4: Check Ollama API on apollo
  echo -n "Testing Ollama API availability... "
  local ollama_check
  ollama_check=$(ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" \
    "curl -s http://localhost:11434/api/tags" 2>/dev/null)
  if [ -n "$ollama_check" ]; then
    echo -e "${GREEN}✓ PASS${NC}"
    ((passed_tests++))
  else
    echo -e "${RED}✗ FAIL${NC} (Ollama API not responding)"
    ((failed_tests++))
  fi

  # Test 5: Check Mistral model availability
  echo -n "Testing Mistral model availability... "
  local model_check
  model_check=$(ssh -p "$APOLLO_PORT" "$APOLLO_USER@$APOLLO_HOST" \
    "curl -s http://localhost:11434/api/tags" 2>/dev/null | grep -o "\"name\":\"$OLLAMA_MODEL[^\"]*\"" | head -1)
  if [ -n "$model_check" ]; then
    echo -e "${GREEN}✓ PASS${NC}"
    ((passed_tests++))
  else
    echo -e "${YELLOW}⚠ WARN${NC} (model '$OLLAMA_MODEL' not found, but Ollama is running)"
    ((failed_tests++))
  fi

  # Test 6: Check SYSDAWG.md exists
  echo -n "Testing SYSDAWG.md context file... "
  if [ -f "$SYSDAWG_CONTEXT_FILE" ]; then
    echo -e "${GREEN}✓ PASS${NC}"
    ((passed_tests++))
  else
    echo -e "${RED}✗ FAIL${NC} (SYSDAWG.md not found)"
    ((failed_tests++))
  fi

  # Test 7: Gather diagnostics
  echo -n "Testing diagnostic gathering... "
  local test_diag
  test_diag=$(gather_diagnostics 2>&1)
  if [ -n "$test_diag" ] && echo "$test_diag" | grep -q "SYSTEM INFO"; then
    echo -e "${GREEN}✓ PASS${NC}"
    ((passed_tests++))
  else
    echo -e "${RED}✗ FAIL${NC} (diagnostic gathering failed)"
    ((failed_tests++))
  fi

  # Test 8: Simple Mistral query
  echo -n "Testing Mistral query (this may take 10-20s)... "
  local test_response
  test_response=$(send_to_mistral "You are a test assistant." "Reply with exactly: TEST OK" 2>&1)
  if [ -n "$test_response" ]; then
    echo -e "${GREEN}✓ PASS${NC}"
    ((passed_tests++))
    echo "  Response preview: ${CYAN}$(echo "$test_response" | head -c 60)...${NC}"
  else
    echo -e "${RED}✗ FAIL${NC} (no response from Mistral)"
    ((failed_tests++))
  fi

  # Summary
  echo ""
  echo -e "${CYAN}═══════════════════════════════════════════════════${NC}"
  echo -e "  Passed: ${GREEN}$passed_tests${NC}"
  echo -e "  Failed: ${RED}$failed_tests${NC}"

  if [ $failed_tests -eq 0 ]; then
    echo -e "${GREEN}  All tests passed!${NC}"
  else
    echo -e "${YELLOW}  Some tests failed. Check configuration.${NC}"
  fi
  echo -e "${CYAN}═══════════════════════════════════════════════════${NC}"
  echo ""
}

# Handle slash commands
handle_slash_command() {
  local command="$1"

  case "$command" in
    /exit|/quit)
      log_info "Exiting sysdawg. Goodbye!"
      exit 0
      ;;
    /help)
      echo ""
      echo -e "${CYAN}Available Commands:${NC}"
      echo "  /help      - Show this help message"
      echo "  /clear     - Clear conversation history"
      echo "  /refresh   - Re-gather system diagnostics"
      echo "  /status    - Toggle diagnostics inclusion (current: $([ "$INCLUDE_DIAGNOSTICS" = true ] && echo 'ON' || echo 'OFF'))"
      echo "  /tests     - Run comprehensive test suite"
      echo "  /debug     - Toggle debug mode (current: $([ "$DEBUG_MODE" = true ] && echo 'ON' || echo 'OFF'))"
      echo "  /exit      - Exit interactive mode"
      echo ""
      return 0
      ;;
    /clear)
      CONVERSATION_HISTORY=()
      log_success "Conversation history cleared"
      return 0
      ;;
    /refresh)
      refresh_diagnostics
      return 0
      ;;
    /status)
      if [ "$INCLUDE_DIAGNOSTICS" = true ]; then
        INCLUDE_DIAGNOSTICS=false
        log_success "Diagnostics: OFF (prompts will be more concise)"
      else
        INCLUDE_DIAGNOSTICS=true
        log_success "Diagnostics: ON (system state included in prompts)"
      fi
      return 0
      ;;
    /tests)
      run_tests
      return 0
      ;;
    /debug)
      if [ "$DEBUG_MODE" = true ]; then
        DEBUG_MODE=false
        log_success "Debug mode: OFF"
      else
        DEBUG_MODE=true
        log_success "Debug mode: ON (will show JSON requests/responses)"
      fi
      return 0
      ;;
    *)
      log_warn "Unknown command: $command"
      echo "Type /help for available commands"
      return 1
      ;;
  esac
}

# Available slash commands for autocomplete
SLASH_COMMANDS=("/help" "/clear" "/refresh" "/status" "/tests" "/debug" "/exit" "/quit")

# Show command suggestions
show_command_suggestions() {
  local partial="$1"
  local matches=()

  # Find matching commands
  for cmd in "${SLASH_COMMANDS[@]}"; do
    if [[ "$cmd" == "$partial"* ]]; then
      matches+=("$cmd")
    fi
  done

  # Display suggestions if we have matches
  if [ ${#matches[@]} -gt 0 ]; then
    echo -e "\n${CYAN}Suggestions:${NC} ${matches[*]}" >&2
  fi
}

# Bash completion for slash commands
_sysdawg_completions() {
  local cur="${COMP_WORDS[COMP_CWORD]}"

  # Only complete if current word starts with /
  if [[ "$cur" == /* ]]; then
    COMPREPLY=($(compgen -W "${SLASH_COMMANDS[*]}" -- "$cur"))
  fi
}

# Read user input with proper readline support
read_with_completion() {
  local input=""

  # Use read with readline editing enabled
  # -e enables readline, -r prevents backslash escaping
  # Echo the prompt separately so ANSI codes work
  read -e -r input

  echo "$input"
}

# Interactive REPL mode
interactive_mode() {
  echo ""
  echo -e "${MAGENTA}╔══════════════════════════════════════════════════════╗${NC}"
  echo -e "${MAGENTA}║${NC}                                                          ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}   ${CYAN}███████╗██╗   ██╗███████╗██████╗  █████╗ ██╗    ██╗ ██████╗${NC}  ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}   ${CYAN}██╔════╝╚██╗ ██╔╝██╔════╝██╔══██╗██╔══██╗██║    ██║██╔════╝${NC}  ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}   ${CYAN}███████╗ ╚████╔╝ ███████╗██║  ██║███████║██║ █╗ ██║██║  ███╗${NC}  ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}   ${CYAN}╚════██║  ╚██╔╝  ╚════██║██║  ██║██╔══██║██║███╗██║██║   ██║${NC}  ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}   ${CYAN}███████║   ██║   ███████║██████╔╝██║  ██║╚███╔███╔╝╚██████╔╝${NC}  ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}   ${CYAN}╚══════╝   ╚═╝   ╚══════╝╚═════╝ ╚═╝  ╚═╝ ╚══╝╚══╝ ╚═════╝${NC}   ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}                                                          ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}         ${GREEN}Junior SRE Copilot Powered by Mistral 7B${NC}           ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}║${NC}                                                          ${MAGENTA}║${NC}"
  echo -e "${MAGENTA}╚══════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "Type your questions below. Use ${CYAN}/help${NC} for commands, ${CYAN}/exit${NC} to quit."
  echo -e "Press ${CYAN}TAB${NC} after typing ${CYAN}/${NC} to autocomplete commands."
  echo ""

  # Enable completion for this session
  complete -F _sysdawg_completions sysdawg_input 2>/dev/null || true

  while true; do
    # Show prompt with colors, then read input with completion support
    echo -n -e "${CYAN}> ${NC}"
    user_input=$(read_with_completion)

    # Handle empty input
    if [ -z "$user_input" ]; then
      continue
    fi

    # Check for slash command
    if [[ "$user_input" =~ ^/ ]]; then
      handle_slash_command "$user_input"
      continue
    fi

    # Add user message to history
    CONVERSATION_HISTORY+=("$user_input")

    # Build messages for Mistral
    local system_msg user_msg
    system_msg=$(build_system_message)
    user_msg=$(build_user_message "$user_input")

    log_info "Sending to sysdawg..." >&2

    # Get response
    local response
    response=$(send_to_mistral "$system_msg" "$user_msg")

    if [ $? -ne 0 ]; then
      log_error "Failed to get response from Mistral"
      # Remove the user message from history since we didn't get a response
      CONVERSATION_HISTORY=("${CONVERSATION_HISTORY[@]:0:${#CONVERSATION_HISTORY[@]}-1}")
      continue
    fi

    echo ""
    echo -e "${GREEN}╔═══════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║${NC}         ${GREEN}◆ sysdawg's response ◆${NC}                 ${GREEN}║${NC}"
    echo -e "${GREEN}╚═══════════════════════════════════════════════════╝${NC}"
    echo ""
    echo -e "${GREEN}$response${NC}"
    echo ""

    # Add response to history
    CONVERSATION_HISTORY+=("$response")

    # Trim history if needed
    trim_history
  done
}

# Headless (one-shot) mode
headless_mode() {
  local question="$1"

  # Check prerequisites
  check_env
  load_env
  load_sysdawg_context

  # Verify SSH is working
  test_ssh_connection

  # Gather diagnostics
  log_info "Gathering system diagnostics..." >&2
  CURRENT_DIAGNOSTICS=$(gather_diagnostics)
  DIAGNOSTICS_TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

  # Build messages for Mistral
  CONVERSATION_HISTORY=()
  INCLUDE_DIAGNOSTICS=true
  local system_msg user_msg
  system_msg=$(build_system_message)
  user_msg=$(build_user_message "$question")

  echo ""
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo -e "${CYAN}Mistral 7B Analysis${NC}"
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
  echo ""

  log_info "Sending to sysdawg..." >&2

  # Send to Mistral
  send_to_mistral "$system_msg" "$user_msg"

  echo ""
  echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Main entry point
main() {
  local mode="interactive"
  local question=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -i|--interactive)
        mode="interactive"
        shift
        ;;
      -p)
        # -p takes the next argument as the question
        if [ $# -lt 2 ]; then
          log_error "-p requires a question argument"
          echo ""
          show_help
          exit 1
        fi
        mode="headless"
        question="$2"
        shift 2
        ;;
      --version)
        echo "sysdawg v0.2.0 (Interactive Mode)"
        exit 0
        ;;
      --setup)
        # Run setup script
        if [ -f "$SCRIPT_DIR/setup-ssh.sh" ]; then
          bash "$SCRIPT_DIR/setup-ssh.sh"
          exit 0
        else
          log_error "setup-ssh.sh not found"
          exit 1
        fi
        ;;
      -*)
        log_error "Unknown option: $1"
        echo ""
        show_help
        exit 1
        ;;
      *)
        # For backward compatibility, treat positional args as question in headless mode
        if [ -z "$question" ]; then
          mode="headless"
          question="$*"
        fi
        break
        ;;
    esac
  done

  # Route to appropriate mode
  if [ "$mode" = "headless" ]; then
    if [ -z "$question" ]; then
      log_error "No question provided for headless mode"
      exit 1
    fi
    headless_mode "$question"
  else
    # Interactive mode
    check_env
    load_env
    load_sysdawg_context

    # Verify SSH is working
    test_ssh_connection

    # Gather initial diagnostics
    log_info "Gathering initial system diagnostics..." >&2
    CURRENT_DIAGNOSTICS=$(gather_diagnostics)
    DIAGNOSTICS_TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    log_success "Diagnostics ready" >&2

    # Enter interactive mode
    interactive_mode
  fi
}

# Run main
main "$@"
